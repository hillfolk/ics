{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Author:       François PIETTE
Creation:     Mar 17, 2003
Description:  Decode a MIME data block as generated by a HTML form sent by
              a browser with ENCTYPE="multipart/form-data"
Version:      2.00
EMail:        francois.piette@overbyte.be  http://www.overbyte.be
Support:      Unsupported code.
Legal issues: Copyright (C) 2003-2009 by François PIETTE
              Rue de Grady 24, 4053 Embourg, Belgium. Fax: +32-4-365.74.56
              <francois.piette@overbyte.be>

              This software is provided 'as-is', without any express or
              implied warranty.  In no event will the author be held liable
              for any  damages arising from the use of this software.

              Permission is granted to anyone to use this software for any
              purpose, including commercial applications, and to alter it
              and redistribute it freely, subject to the following
              restrictions:

              1. The origin of this software must not be misrepresented,
                 you must not claim that you wrote the original software.
                 If you use this software in a product, an acknowledgment
                 in the product documentation would be appreciated but is
                 not required.

              2. Altered source versions must be plainly marked as such, and
                 must not be misrepresented as being the original software.

              3. This notice may not be removed or altered from any source
                 distribution.

              4. You must register this software by sending a picture postcard
                 to the author. Use a nice stamp and mention your name, street
                 address, EMail address and any comment you like to say.

History:


 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
unit OverbyteIcsFormDataDecoder;

interface

uses
    SysUtils, Classes;

const
    FormDataDecoderVersion = 100;
    CopyRight : String      = ' FormDataDecoder (c) 2003-2009 F. Piette V2.00 ';

type
    TDisplayEvent = procedure (Sender : TObject; const Msg : String) of object;

    TFormDataAnalyser = class;

    TFormDataItem = class
        Analyser            : TFormDataAnalyser;
        PosHeader           : LongInt;
        PosData             : LongInt;
        DataLength          : LongInt;
        ContentDisposition  : String;
        ContentName         : String;
        ContentFileName     : String;
        ContentType         : String;
        function  AsString  : String;
        procedure SaveToFile(const FileName : String);
    end;

    TFormDataAnalyser = class(TComponent)
    protected
        FData       : TStream;
        FIndex      : TList;
        FDelimiter  : String;
        FOnDisplay  : TDisplayEvent;
        FDataStream : TStream;
        FOwnData    : Boolean;
        FDataString : String;
        function ReadLine : String;
        function GetPartCount : Integer;
        procedure Display(const Msg : String);
        procedure InternalDecodeStream(DataFrom : TStream);
    public
        constructor Create(AOwner : TComponent); override;
        destructor  Destroy; override;
        procedure   DecodeStream(DataFrom : TStream);
        procedure   DecodeString(const DataFrom : String);
        procedure   DecodeFile(const FileName : String);
        procedure   Clear;
        function    Part(const PartName : String) : TFormDataItem; overload;
        function    Part(const PartNumber : Integer) : TFormDataItem; overload;
        function    PartData(const PartName : String) : String; overload;
        function    PartDataLength(const PartName : String) : Integer; overload;
        function    PartDataLength(const PartNumber : Integer) : Integer; overload;
        function    PartContentType(const PartName : String) : String;
        function    PartContentName(const PartNumber : Integer) : String;
        procedure   PartSaveDataToFile(const PartName : String;
                                       const FileName : String);
        property PartCount : Integer       read  GetPartCount;
    published
        property OnDisplay : TDisplayEvent read  FOnDisplay write FOnDisplay;
    end;

procedure Register;

implementation


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure Register;
begin
    RegisterComponents('FPiette', [TFormDataAnalyser]);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
constructor TFormDataAnalyser.Create(AOwner : TComponent);
begin
    inherited Create(AOwner);
    FIndex := TList.Create;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
destructor TFormDataAnalyser.Destroy;
begin
    Clear;
    FreeAndNil(FIndex);
    inherited;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataAnalyser.Clear;
var
    I : Integer;
begin
    if FOwnData then begin
        FOwnData := FALSE;
        FreeAndNil(FDataStream);
    end;
    if Assigned(FIndex) then begin
        for I := FIndex.Count - 1 downto 0 do begin
            TFormDataItem(FIndex.Items[I]).Destroy;
            FIndex.Delete(I);
        end;
    end;
    FDataString := '';
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataAnalyser.Display(const Msg: String);
begin
    if Assigned(FOnDisplay) then
        FOnDisplay(Self, Msg);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.ReadLine: String;
var
    Ch  : AnsiChar;
    Ch1 : AnsiChar;
begin
    Result := '';
    Ch1    := #0;
    while FData.Read(Ch, 1) = 1 do begin
        if (Ch = #10) and (Ch1 = #13) then
            break;
        Ch1    := Ch;
        if Ch <> #13 then
            Result := Result + Char(Ch);
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function GetToken(
    var Line  : String;
    var I     : Integer;
    out Delim : Char) : String;
begin
    Result := '';
    while (I <= Length(Line)) and (Line[I] = ' ') do
        Inc(I);
    while (I <= Length(Line)) and (not ((Line[I] = ';') or (Line[I] = '='))) do begin
        Result := Result + Line[I];
        Inc(I);
    end;
    if I <= Length(Line) then begin
        Delim := Line[I];
        Inc(I);   // Skip delimiter
    end
    else
        Delim := #13;
    // Remove double-quotes if found around token
    if (Length(Result) >= 2) and
       (Result[1] = '"') and (Result[Length(Result)] = '"') then begin
        Delete(Result, 1, 1);
        Delete(Result, Length(Result), 1);
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataAnalyser.InternalDecodeStream(DataFrom : TStream);
var
    Item    : TFormDataItem;
    Line    : String;
    I       : Integer;
    HdrType : String;
    Element : String;
    Delim   : Char;
    Ch      : AnsiChar;
    EOD     : array [0..1] of AnsiChar;
begin
    FData := DataFrom;
    FDelimiter := #13#10 + ReadLine;
    while TRUE do begin
        // Allocate a new item and add it to the list
        Item := TFormDataItem.Create;
        FIndex.Add(Item);
        Item.Analyser := Self;
        Display('Part ' + IntToStr(FIndex.Count));
        // Remember header position in input stream
        Item.PosHeader := FData.Position;
        // Read header
        while TRUE do begin
            Line := ReadLine;
            if Line = '' then               // End of header
                break;
            I := Pos(':', Line);
            if I > 1 then begin
                // Correct header line, decode
                HdrType := Copy(Line, 1, I - 1);
                Inc(I);
                if CompareText(HdrType, 'Content-Disposition') = 0 then begin
                    Item.ContentDisposition := GetToken(Line, I, Delim);
                    if CompareText(Item.ContentDisposition, 'form-data') = 0 then begin
                        while TRUE do begin
                            Element := GetToken(Line, I, Delim);
                            if Element = '' then
                                break;
                            if CompareText(Element, 'Name') = 0 then
                                Item.ContentName := GetToken(Line, I, Delim)
                            else if CompareText(Element, 'FileName') = 0 then
                                Item.ContentFileName := GetToken(Line, I, Delim);
                        end;
                    end;
                end
                else if CompareText(HdrType, 'Content-Type') = 0 then begin
                    Item.ContentType := GetToken(Line, I, Delim);
                end;
            end;
        end;
        Item.PosData := FData.Position;
        // Read data until next delimiter
        I := 1;
        while TRUE do begin
            if FData.Read(Ch, 1) <> 1 then
                break;  // End of file
            if Char(Ch) <> FDelimiter[I] then begin
                if I > 1 then
                    FData.Seek(1 - I, soFromCurrent);
                I := 1;
                Continue;
            end;
            if I = Length(FDelimiter) then
                break;
            Inc(I);
        end;
        Item.DataLength := FData.Position - Length(FDelimiter) - Item.PosData;

        Display('  Name: ' + Item.ContentName);
        Display('  FileName: ' + Item.ContentFileName);
        Display('  DataLength: ' + IntToStr(Item.DataLength));
        Display('  ContentType: ' + Item.ContentType);

        if FData.Read(EOD, 2) <> 2 then
            break;     // EOF, should not be so !
        if not ((Char(EOD[0]) = #13) and (Char(EOD[1]) = #10)) then
            break;     // No more parts, should be '--'
    end;
    Display('End.');
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.GetPartCount: Integer;
begin
    if not Assigned(FIndex) then
        Result := 0
    else
        Result := FIndex.Count;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.Part(const PartName: String): TFormDataItem;
var
    I : Integer;
begin
    if not Assigned(FIndex) then begin
        Result := nil;
        Exit;
    end;

    for I := 0 to FIndex.Count - 1 do begin
        Result := FIndex.Items[I];
        if CompareText(Result.ContentName, PartName) = 0 then
            Exit;
    end;
    Result := nil;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.Part(const PartNumber: Integer): TFormDataItem;
begin
    if not Assigned(FIndex) then
        Result := nil
    else if (PartNumber < 0) or (PartNumber >= FIndex.Count) then
        Result := nil
    else
        Result := FIndex.Items[PartNumber];
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.PartData(const PartName: String): String;
var
    Item : TFormDataItem;
begin
    Item := Part(PartName);
    if not Assigned(Item) then
        Result := ''
    else begin
        SetLength(Result, Item.DataLength);
        FData.Seek(Item.PosData, soFromBeginning);
        FData.Read(Result[1], Item.DataLength);
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.PartDataLength(const PartName : String) : Integer;
var
    Item : TFormDataItem;
begin
    Item := Part(PartName);
    if not Assigned(Item) then
        Result := -1
    else
        Result := Item.DataLength;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.PartDataLength(const PartNumber : Integer) : Integer;
var
    Item : TFormDataItem;
begin
    Item := Part(PartNumber);
    if not Assigned(Item) then
        Result := -1
    else
        Result := Item.DataLength;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.PartContentType(const PartName : String) : String;
var
    Item : TFormDataItem;
begin
    Item := Part(PartName);
    if not Assigned(Item) then
        Result := ''
    else
        Result := Item.ContentType;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataAnalyser.PartContentName(const PartNumber : Integer) : String;
var
    Item : TFormDataItem;
begin
    Item := Part(PartNumber);
    if not Assigned(Item) then
        Result := ''
    else
        Result := Item.ContentName;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataAnalyser.PartSaveDataToFile(
    const PartName: String;
    const FileName: String);
var
    ToStream  : TFileStream;
    Item      : TFormDataItem;
    Buffer    : array [0..4095] of char;
    Count     : Integer;
    ToRead    : Integer;
begin
    Item := Part(PartName);
    if Assigned(Item) then begin
        ToStream := TFileStream.Create(FileName, fmCreate);
        try
            FData.Seek(Item.PosData, soFromBeginning);
            ToRead := Item.DataLength;
            while ToRead > 0 do begin
                if ToRead > SizeOf(Buffer) then
                    Count := FData.Read(Buffer, SizeOf(Buffer))
                else
                    Count := FData.Read(Buffer, ToRead);
                if Count <= 0 then
                    break;
                ToStream.Write(Buffer, Count);
                ToRead := ToRead - Count;
            end;
        finally
            ToStream.Destroy;
        end;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataAnalyser.DecodeString(const DataFrom: String);
begin
    Clear;
    FOwnData    := TRUE;
    FDataString := DataFrom;
    FDataStream := TStringStream.Create(FDataString);
    InternalDecodeStream(FDataStream);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataAnalyser.DecodeFile(const FileName: String);
begin
    Clear;
    FOwnData    := TRUE;
    FDataStream := TFileStream.Create(FileName, fmOpenRead);
    InternalDecodeStream(FDataStream);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataAnalyser.DecodeStream(DataFrom: TStream);
begin
    Clear;
    FDataStream := DataFrom;
    InternalDecodeStream(FDataStream);
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
function TFormDataItem.AsString: String;
{$IF SizeOf(Char) = 2}
var
    Temp : AnsiString;
{$IFEND}
begin
    if not Assigned(Self) then
        Result := ''
    else begin
{$IF SizeOf(Char) = 2}
        SetLength(Temp, DataLength);
        Analyser.FData.Seek(PosData, soFromBeginning);
        Analyser.FData.Read(Temp[1], DataLength);
        Result := String(Temp);
{$ELSE}
        SetLength(Result, DataLength);
        Analyser.FData.Seek(PosData, soFromBeginning);
        Analyser.FData.Read(Result[1], DataLength);
{$IFEND}
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
procedure TFormDataItem.SaveToFile(const FileName: String);
var
    ToStream  : TFileStream;
    Buffer    : array [0..4095] of char;
    Count     : Integer;
    ToRead    : Integer;
begin
    if not Assigned(Self) then
        Exit;
    ToStream := TFileStream.Create(FileName, fmCreate);
    try
        Analyser.FData.Seek(PosData, soFromBeginning);
        ToRead := DataLength;
        while ToRead > 0 do begin
            if ToRead > SizeOf(Buffer) then
                Count := Analyser.FData.Read(Buffer, SizeOf(Buffer))
            else
                Count := Analyser.FData.Read(Buffer, ToRead);
            if Count <= 0 then
                break;
            ToStream.Write(Buffer, Count);
            ToRead := ToRead - Count;
        end;
    finally
        ToStream.Destroy;
    end;
end;


{* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}

end.
